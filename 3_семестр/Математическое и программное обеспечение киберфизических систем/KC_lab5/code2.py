import numpy as np
import matplotlib.pyplot as plt

# ============================= ВВОД ДАННЫХ =============================
x1 = float(input("Введите скорость интерфейса x1 (Мбит/с): "))
x2_kb = float(input("Введите размер пакета x2 (КБ) для задания 2.6: "))
lambda_26 = float(input("Введите λ (пак/с) для задания 2.6: "))

# ======================== Параметры G.711 ========================
len_10, t_cod_10 = 158, 0.01   # 10 мс кадр → 158 байт (включая все заголовки)
len_30, t_cod_30 = 318, 0.03   # 30 мс кадр → 318 байт

# 2.1–2.2 Реальная полоса пропускания одного VoIP-потока (с заголовками!)
bandwidth_10 = (len_10 * 8) / t_cod_10 / 1000   # кбит/с
bandwidth_30 = (len_30 * 8) / t_cod_30 / 1000

print(f"\n2.1 Полоса передачи G.711 (10 мс кадр): {bandwidth_10:.1f} кбит/с")
print(f"2.2 Полоса передачи G.711 (30 мс кадр): {bandwidth_30:.1f} кбит/с")

# 2.3–2.4 Время передачи одного пакета по каналу (сериализация)
T_10_ms = (len_10 * 8) / (x1 * 1e6) * 1000
T_30_ms = (len_30 * 8) / (x1 * 1e6) * 1000

print(f"2.3 Tср (G.711 10 мс): {T_10_ms:.3f} мс")
print(f"2.4 Tср (G.711 30 мс): {T_30_ms:.3f} мс")

# ================== 2.5 M/M/1 для АКТИВНОГО VoIP-разговора ==================
print(f"\n2.5 Анализ загрузки канала при ОДНОМ АКТИВНОМ VoIP-разговоре (интерфейс {x1} Мбит/с):")

# Внимание! Правильная интенсивность пакетов — во время разговора!
# G.711 генерирует ровно 100 пак/с при 10 мс кадре и 33.33 пак/с при 30 мс
lambda_pac_10 = 1 / t_cod_10          # 100 пак/с
lambda_pac_30 = 1 / t_cod_30          # ≈33.333 пак/с

# Интенсивность обслуживания (сколько пакетов канал может передать в секунду)
mu_10 = (x1 * 1e6) / (len_10 * 8)     # пак/с
mu_30 = (x1 * 1e6) / (len_30 * 8)

# Коэффициент загрузки ρ = λ / μ
rho_10 = lambda_pac_10 / mu_10
rho_30 = lambda_pac_30 / mu_30

# ------------------- Вывод и графики -------------------
t_ms = np.linspace(0, 20, 1000)       # увеличил до 20 мс — удобнее видеть хвост
t_sec = t_ms / 1000

def plot_cdf(rho, mu, title, label):
    if rho >= 1:
        print(f"   {label}: ρ = {rho:.4f} ≥ 1 → СИСТЕМА НЕСТАБИЛЬНА!")
    else:
        print(f"   {label}: ρ = {rho:.4f} → устойчиво")
        F = 1 - np.exp(-mu * (1 - rho) * t_sec)
        plt.plot(t_ms, F, label=f'{label}, ρ={rho:.4f}')
        plt.title(title)
        plt.xlabel('Время обслуживания, мс')
        plt.ylabel('F(t) — вероятность окончания обслуживания')
        plt.grid(True)
        plt.legend()
        plt.tight_layout()
        plt.show()

# Графики только при устойчивой системе
plot_cdf(rho_10, mu_10, 'ФРВ времени обслуживания (G.711 10 мс, M/M/1)', 'G.711 (10 мс)')
plot_cdf(rho_30, mu_30, 'ФРВ времени обслуживания (G.711 30 мс, M/M/1)', 'G.711 (30 мс)')

# ============================= 2.6 Произвольный трафик =============================
print(f"\n--- Задание 2.6: произвольный трафик (канал 10 Мбит/с) ---")
delta_t = 0.020
C = 10e6                                # бит/с — жёстко задан в лабе
L_bytes = x2_kb * 1000
L_bits = L_bytes * 8

T_sr = L_bits / C                        # среднее время обслуживания
mu_26 = 1 / T_sr
rho_26 = lambda_26 * T_sr                # ρ = λ × Tобсл

print(f"Δt (задержка в узле) = {delta_t*1000:.0f} мс (информативно)")
print(f"Размер пакета L = {L_bytes} байт ({x2_kb} КБ)")
print(f"Время передачи Tср = {T_sr*1000:.3f} мс")
print(f"ρ = λ × Tср = {rho_26:.4f}")

if rho_26 >= 1:
    print("Система НЕСТАБИЛЬНА (ρ ≥ 1) — очередь растёт бесконечно!")
else:
    print("Система стабильна")
    F_e = 1 - np.exp(-mu_26 * (1 - rho_26) * t_sec)
    plt.figure()
    plt.plot(t_ms, F_e, color='red', linewidth=2, label=f'ρ = {rho_26:.4f}')
    plt.title('ФРВ окончания обслуживания (задание 2.6, M/M/1)')
    plt.xlabel('Время, мс')
    plt.ylabel('F(t)')
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()