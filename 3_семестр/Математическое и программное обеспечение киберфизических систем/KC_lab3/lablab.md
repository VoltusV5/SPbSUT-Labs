#### 2.2. Распределение вероятностей состояний (A = 1000, V = 360)

**Цель раздела:** показать, как для больших значений \(A\) и \(V\) корректно вычислить распределение состояний \(P[x]\) для модели M/M/V/0, объяснить численные нюансы и получить вероятность заполнения всех каналов (блокировки).

---

##### Почему прямой подсчёт с факториалами неисправен

Формула
\[
P[x] = \frac{A^x / x!}{\sum_{i=0}^{V} A^i / i!}
\]
правильна теоретически, но при больших \(A\) и \(V\) вычисления вида \(A^x\) и \(x!\) приводят к переполнениям или потере точности в стандартной плавающей арифметике. Поэтому применяют численно устойчивые приёмы:
- рекуррентное вычисление отношения \(P[x]/P[x-1] = \frac{A}{x}\), либо
- вычисление в лог-пространстве (log-space) с последующей нормализацией через log-sum-exp.

Также важный факт: для системы M/M/V/0 вероятность потерь (блокировки) равна \(P[V]\) — вероятности того, что все \(V\) каналов заняты при моменте прихода вызова. Это и есть Erlang B.

---

##### Подход, который используем здесь
1. Вычисляем лог-вероятности последовательно:
   \[
   \log \tilde p_0 = 0,\quad \log \tilde p_x = \log \tilde p_{x-1} + \log A - \log x
   \]
   где \(\tilde p_x = A^x/x!\) (ненормированное).
2. Находим \(\max(\log \tilde p_x)\), применяем сдвиг для численной устойчивости:
   \[
   q_x = \exp(\log \tilde p_x - M),\quad M = \max_x \log \tilde p_x
   \]
3. Нормируем:
   \[
   P[x] = \frac{q_x}{\sum_{i=0}^{V} q_i}
   \]
4. Дополнительно проверяем \(P[V]\) с помощью рекуррентной формулы Erlang B:
   \[
   E_0 = 1,\qquad E_v = \frac{A\cdot E_{v-1}}{v + A\cdot E_{v-1}}
   \]
   — результат должен совпадать с \(P[V]\).

---

##### Пример (A = 1000, V = 360) — интерпретация результатов
- Для этих параметров численно получается, что \(P[V] \approx 0.64056\).  
  Это означает: вероятность того, что при приходу вызова *все* 360 каналов заняты, ≈ **64.06%** — т.е. блокировка очень высокая.
- Обслуженная доля: \(1 - P[V] \approx 0.35944\) → обслуживается ≈ **359.44 Эрл.** из 1000 предложенных.
- Средняя загрузка одного канала: \(\text{util} \approx 359.44 / 360 \approx 0.9984\) (≈ **99.84%**).

---

!!! График распределения вероятностей состояний \(P[x]\) для \(x=0\ldots360\) (логично показать, что распределение монотонно растёт к \(x=V\) при \(A \gg V\))

---

##### Код (Python) — вычисление в лог-пространстве + проверка рекуррентом Erlang B

```python
# Вычисление распределения P[x] для больших A,V в лог-пространстве
import math

A = 1000.0
V = 360

# 1) лог-ненормированные p_tilde: log(A^x / x!) используя рекуррент
log_p = [0.0]        # log_p[0] = log(1) = 0
for x in range(1, V + 1):
    log_p.append(log_p[-1] + math.log(A) - math.log(x))

# 2) стабилизация: вычитаем максимум
M = max(log_p)
q = [math.exp(lp - M) for lp in log_p]   # маленькие и численно стабильные значения

# 3) нормировка
Z = sum(q)
P = [qx / Z for qx in q]  # P[x] для x=0..V

# 4) вывод ключевых значений
print(f"P[V] (вероятность, что все V={V} каналов заняты) = {P[V]:.8f}")
print(f"Процент отказов = {P[V]*100:.2f}%")
print(f"Доля обслуженных вызовов = {(1 - P[V])*100:.4f}%")
carried = A * (1 - P[V])
util = carried / V
print(f"Обслуженная нагрузка (carried traffic) = {carried:.6f} Эрл.")
print(f"Средняя загрузка одного канала = {util:.6f} (≈{util*100:.2f}%)")

# 5) Проверка через рекуррентную формулу Erlang B
E = 1.0
for v in range(1, V + 1):
    E = (A * E) / (v + A * E)
print(f"Проверка (Erlang B recurrence): E_{V}({A}) = {E:.8f}")
# Ожидаем E ≈ P[V]
